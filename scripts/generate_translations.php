<?php
/**
 * Copyright (C) 2020 - 2023 | Valiant Network / Matthew Jordan
 *
 * This program is private software. You may not redistribute this software, or
 * any derivative works of this software, in source or binary form, without
 * the express permission of the owner.
 *
 * @author sylvrs
 */
declare(strict_types=1);

$baseDirectory = dirname(__FILE__, 2);

require_once("$baseDirectory/vendor/autoload.php");

const TAB = "\t";
const HEADER = <<<HEADER
<?php
/**
 * Copyright (C) 2020 - 2023 | Valiant Network / Matthew Jordan
 *
 * This program is private software. You may not redistribute this software, or
 * any derivative works of this software, in source or binary form, without
 * the express permission of the owner.
 *
 * @author sylvrs
 */
declare(strict_types=1);

namespace {%NAMESPACE};

{%IMPORTS}

/**
 * This class was automatically generated by /scripts/generate_translations.php
 * Do not edit this file manually.
 */
final class {%NAME} {
HEADER;

const FOOTER = <<<FOOTER

	private function __construct() {
	}
}
FOOTER;

/**
 * @param array<string> $imports
 */
function generate_header(string $namespace, string $name, array $imports = []): string {
	$initial = str_replace(["{%NAMESPACE}", "{%NAME}"], [$namespace, $name], HEADER);
	$imports = implode(PHP_EOL, array_map(fn(string $import) => "use $import;", $imports));
	return str_replace("{%IMPORTS}", $imports, $initial);
}

/**
 * @param Closure(): string $generator
 * @param array<string> $imports
 */
function generate_file(string $namespace, string $name, Closure $generator, array $imports = []): void {
	global $baseDirectory;
	$outputDirectory = $baseDirectory . "/src/$namespace";

	$output = generate_header(namespace: $namespace, name: $name, imports: $imports) . PHP_EOL;
	$output .= $generator();
	$output .= FOOTER . PHP_EOL;

	if (!is_dir($outputDirectory)) {
		mkdir($outputDirectory, 0777, true);
	}
	if (!file_exists("$outputDirectory/$name.php")) {
		touch("$outputDirectory/$name.php");
	}
	file_put_contents("$outputDirectory/$name.php", $output);
}

$messages = parse_ini_file("$baseDirectory/resources/messages.ini", true);
/** @var array<string, string[]> $translations */
$translations = [];
foreach ($messages as $key => $translation) {
	$parameters = [];
	$matchCount = preg_match_all("/\{%([a-zA-Z0-9_]+)}/", $translation, $matches);
	if (is_int($matchCount) && $matchCount > 0) {
		foreach ($matches[1] as $match) {
			$parameters[] = $match;
		}
	}
	$translations[$key] = array_unique($parameters);
}

generate_file(namespace: "essence\\translation", name: "EssenceTranslationKeys", generator: function () use($translations): string {
	$constants = "";
	foreach ($translations as $key => $parameters) {
		$name = strtoupper(str_replace([".", " ", "-"], "_", $key));
		$constants .= TAB . "public const $name = \"$key\";" . PHP_EOL;
	}
	return $constants;
});

generate_file(
	namespace: "essence\\translation",
	name: "EssenceTranslationFactory",
	generator: function () use($translations): string {
		$data = "";
		foreach ($translations as $key => $parameters) {
			$name = str_replace([".", " ", "-"], "_", $key);

			$constant = strtoupper($name);
			$functionParams = implode(
				separator: ", ",
				array: array_map(
					callback: fn (string $item): string => "string \$$item",
					array: $parameters,
				)
			);
			$arguments = array_map(fn(string $param): string => "\"$param\" => \$$param", $parameters);
			$data .= TAB . "public static function $name($functionParams): Translatable {" . PHP_EOL;
			$data .= TAB . TAB . "return new Translatable(text: EssenceTranslationKeys::$constant, params: [" . implode(", ", $arguments) . "]);" . PHP_EOL;
			$data .= TAB . "}" . PHP_EOL;
			$data .= PHP_EOL;
		}
		return $data;
	},
	imports: ["pocketmine\\lang\\Translatable"]
);
